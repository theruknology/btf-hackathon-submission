"""
CompliOps Backend Application
A FastAPI-based compliance automation platform with agentic AI capabilities.

Features:
- Watchtower: Automated compliance change detection
- Executor: Report generation via crew.ai agents
- Reliable Chat: RAG-based compliance Q&A
- Robust mocking for graceful degradation without API keys
"""

import os
import json
import logging
from datetime import datetime
from typing import Optional, List
from contextlib import asynccontextmanager

# FastAPI & Web Framework
from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field

# Database
from sqlalchemy import create_engine, Column, String, DateTime, Integer, JSON, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session

# AI & Agentic Framework
from crew import Agent, Task, Crew

# Scheduling
from apscheduler.schedulers.background import BackgroundScheduler

# Google Gemini
from google.generativeai import GenerativeAI, ChatSession

# Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ============================================================================
# DATABASE SETUP
# ============================================================================

DATABASE_URL = "sqlite:///./complios.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


class User(Base):
    """User model for dummy auth."""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    password_hash = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)


class ComplianceAlert(Base):
    """Stores compliance alerts detected by Watchtower."""
    __tablename__ = "compliance_alerts"
    
    id = Column(Integer, primary_key=True, index=True)
    source = Column(String, default="watchtower")
    summary = Column(String)
    impact_json = Column(JSON)  # Stores analysis as JSON
    action_required = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)


class GeneratedReport(Base):
    """Stores reports generated by the Executor."""
    __tablename__ = "generated_reports"
    
    id = Column(Integer, primary_key=True, index=True)
    alert_id = Column(Integer, index=True)
    status = Column(String, default="completed")  # completed, failed, in_progress
    title = Column(String)
    content_markdown = Column(String)  # Full Markdown report
    created_at = Column(DateTime, default=datetime.utcnow)


# Create all tables on startup
Base.metadata.create_all(bind=engine)


# ============================================================================
# PYDANTIC MODELS (API Request/Response)
# ============================================================================

class LoginRequest(BaseModel):
    """Dummy login request."""
    email: str
    password: str


class LoginResponse(BaseModel):
    """Mock JWT token response."""
    access_token: str = Field(..., description="Mock JWT token")
    token_type: str = "bearer"


class ComplianceAlertResponse(BaseModel):
    """Response model for compliance alerts."""
    id: int
    source: str
    summary: str
    impact_json: dict
    action_required: bool
    created_at: datetime
    
    class Config:
        from_attributes = True


class GeneratedReportResponse(BaseModel):
    """Response model for generated reports."""
    id: int
    alert_id: int
    status: str
    title: str
    content_markdown: str
    created_at: datetime
    
    class Config:
        from_attributes = True


class ChatRequest(BaseModel):
    """Request model for the RAG chat endpoint."""
    query: str


class ChatResponse(BaseModel):
    """Response model for the RAG chat endpoint."""
    answer: str
    source: str


# ============================================================================
# ENVIRONMENT & LLM SETUP
# ============================================================================

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# Initialize Gemini LLM only if API key exists
llm = None
if GEMINI_API_KEY:
    try:
        from langchain_google_genai import ChatGoogleGenerativeAI
        llm = ChatGoogleGenerativeAI(
            model="gemini-1.5-pro-latest",
            google_api_key=GEMINI_API_KEY,
            temperature=0.7,
        )
        logger.info("âœ“ Gemini API initialized successfully")
    except Exception as e:
        logger.warning(f"âš  Failed to initialize Gemini API: {e}")
        llm = None
else:
    logger.warning("âš  GEMINI_API_KEY not set. Running in MOCK mode.")


# ============================================================================
# MOCK DATA STORE (For RAG Chat)
# ============================================================================

mock_vector_store = {
    "bnpl": (
        "SAMA Circular 123 states that 'Buy Now, Pay Later' (BNPL) services must: "
        "1) Clearly disclose all fees and terms before purchase; "
        "2) Comply with consumer protection standards; "
        "3) Maintain adequate capital reserves; "
        "4) Report all transactions to SAMA within 24 hours."
    ),
    "data residency": (
        "The CBUAE rulebook requires all Personally Identifiable Information (PII) data to be "
        "stored within UAE borders unless explicitly approved by the regulator. "
        "Data residency compliance is mandatory for all fintech operators."
    ),
    "kyc": (
        "Know Your Customer (KYC) requirements mandate that financial institutions verify "
        "customer identity through government-issued ID, biometric data, and address verification. "
        "Re-verification is required annually or when significant changes are detected."
    ),
    "aml": (
        "Anti-Money Laundering (AML) regulations require transaction monitoring, "
        "Suspicious Activity Reporting (SAR), and Customer Due Diligence (CDD) at account opening. "
        "Threshold: transactions above AED 500,000 require enhanced due diligence."
    ),
}


# ============================================================================
# WATCHTOWER BACKGROUND SCHEDULER
# ============================================================================

scheduler = BackgroundScheduler()
last_scraped_content = None


def run_watchtower_check():
    """
    Simulates Watchtower checking for compliance changes every 2 minutes.
    
    Logic:
    - Uses even/odd minutes to toggle between two different "scraped" contents
    - If content changes, triggers Gemini analysis (or mock if no API key)
    - Saves alert to database
    """
    global last_scraped_content
    
    # Simulate scraping: alternate content based on even/odd minute
    current_minute = datetime.now().minute
    if current_minute % 2 == 0:
        new_content = "SAMA updated consumer protection guidelines on microfinance lending."
    else:
        new_content = "CBUAE released new AML screening procedures for fintech operators."
    
    # Check if content changed
    if last_scraped_content != new_content:
        logger.info(f"ðŸ”” WATCHTOWER: Change detected! Content: {new_content}")
        last_scraped_content = new_content
        
        # Analyze the change
        if GEMINI_API_KEY and llm:
            # Real API call
            try:
                analysis_prompt = f"""Analyze this compliance update and provide:
                1. A one-line summary
                2. Impact level (Low/Medium/High)
                3. Required actions (list 2-3 items)
                
                Update: {new_content}
                
                Return as JSON."""
                
                response = llm.invoke(analysis_prompt)
                analysis_text = response.content
                
                # Parse JSON from response
                try:
                    analysis = json.loads(analysis_text)
                except json.JSONDecodeError:
                    # Fallback if response isn't valid JSON
                    analysis = {
                        "summary": new_content,
                        "impact": "Medium",
                        "action_required": True,
                        "actions": ["Review update", "Update compliance docs"]
                    }
                
                logger.info(f"âœ“ WATCHTOWER: Real API analysis completed")
            except Exception as e:
                logger.error(f"âœ— WATCHTOWER: API error: {e}. Falling back to mock.")
                analysis = generate_mock_watchtower_analysis(new_content)
        else:
            # Mock analysis (no API key)
            logger.info("WATCHTOWER: No API key. Generating mock analysis.")
            analysis = generate_mock_watchtower_analysis(new_content)
        
        # Save to database
        db = SessionLocal()
        try:
            alert = ComplianceAlert(
                source="watchtower",
                summary=analysis.get("summary", new_content),
                impact_json=analysis,
                action_required=analysis.get("action_required", True),
            )
            db.add(alert)
            db.commit()
            logger.info(f"âœ“ WATCHTOWER: Alert saved to DB (ID: {alert.id})")
        except Exception as e:
            logger.error(f"âœ— WATCHTOWER: Failed to save alert: {e}")
            db.rollback()
        finally:
            db.close()


def generate_mock_watchtower_analysis(content: str) -> dict:
    """
    Generates realistic mock analysis for Watchtower when API is unavailable.
    """
    return {
        "summary": content,
        "impact": "High",
        "action_required": True,
        "actions": [
            "Review compliance documentation",
            "Update internal policies",
            "Notify compliance team immediately"
        ],
        "source": "Mock Watchtower Analysis"
    }


# ============================================================================
# CREW.AI AGENTS & EXECUTOR
# ============================================================================

def get_compliance_analyst_agent():
    """Creates the Compliance Analyst agent for Executor."""
    return Agent(
        role="Compliance Analyst",
        goal="Analyze compliance alerts and extract key information for report generation",
        backstory="Expert compliance analyst with 10+ years in fintech regulations",
        llm=llm,  # Will be None if no API key
        verbose=True,
    )


def get_company_data_fetcher_agent():
    """Creates the Company Data Fetcher agent for Executor."""
    return Agent(
        role="Company Data Fetcher",
        goal="Retrieve company metadata and data locations for compliance reporting",
        backstory="Data architect familiar with cloud infrastructure and data governance",
        llm=llm,
        verbose=True,
    )


def get_report_writer_agent():
    """Creates the Report Writer agent for Executor."""
    return Agent(
        role="Compliance Report Writer",
        goal="Write comprehensive, professional compliance reports in Markdown",
        backstory="Technical writer specializing in compliance and regulatory documentation",
        llm=llm,
        verbose=True,
    )


def generate_mock_executor_report(alert: ComplianceAlert, company_data: dict) -> str:
    """
    Generates a realistic mock Markdown report when API is unavailable.
    """
    return f"""# Compliance Report

## Executive Summary

This report addresses the compliance alert: **{alert.summary}**

### Impact Assessment
- **Severity Level**: {alert.impact_json.get('impact', 'Medium')}
- **Status**: Action Required
- **Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Company Details

- **Organization**: {company_data.get('company_name', 'N/A')}
- **User Base**: {company_data.get('user_count', 'N/A')} users
- **Data Locations**: {', '.join(company_data.get('data_locations', ['N/A']))}

## Compliance Findings

### Alert Details
{alert.summary}

### Required Actions
1. Review current compliance posture against new requirements
2. Update data residency and processing agreements if necessary
3. Conduct internal training for relevant teams
4. Document changes in compliance tracking system

### Risk Assessment
**Current Risk Level**: Medium-High

This alert requires immediate attention to ensure ongoing regulatory compliance and operational continuity.

### Recommendations

1. **Immediate (0-7 days)**
   - Conduct thorough compliance audit
   - Identify affected systems and processes
   - Begin stakeholder communication

2. **Short-term (1-2 weeks)**
   - Implement required policy changes
   - Update documentation
   - Deploy changes to production

3. **Follow-up (30+ days)**
   - Verify compliance through testing
   - Conduct regulatory reporting if required
   - Schedule follow-up audit

## Conclusion

This report has been automatically generated based on detected compliance alerts. 
All recommendations should be reviewed by your compliance team and implemented per your organization's change management procedures.

---
*Report generated by CompliOps Executor*
*Mock Report (No API Key)*
"""


# ============================================================================
# FASTAPI APP SETUP
# ============================================================================

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifecycle manager for FastAPI app.
    Starts background scheduler on startup, stops on shutdown.
    """
    # Startup
    logger.info("ðŸš€ CompliOps Backend Starting...")
    scheduler.add_job(run_watchtower_check, "interval", minutes=2, id="watchtower")
    scheduler.start()
    logger.info("âœ“ Watchtower scheduler started (runs every 2 minutes)")
    yield
    
    # Shutdown
    scheduler.shutdown()
    logger.info("ðŸ›‘ CompliOps Backend Shutting Down...")


app = FastAPI(
    title="CompliOps API",
    description="Compliance Automation Platform with Agentic AI",
    version="1.0.0",
    lifespan=lifespan,
)

# Add CORS middleware for Next.js frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins for development
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ============================================================================
# API ENDPOINTS - AUTHENTICATION
# ============================================================================

@app.post("/api/v1/login", response_model=LoginResponse)
async def login(request: LoginRequest):
    """
    Dummy login endpoint. Accepts any email/password and returns a mock JWT token.
    
    Args:
        request: LoginRequest with email and password
    
    Returns:
        LoginResponse with mock token
    """
    # In a real app, validate credentials against database
    # For now, accept any email/password
    mock_token = f"mock_jwt_token_{request.email}_{datetime.now().timestamp()}"
    logger.info(f"âœ“ Login: {request.email}")
    return LoginResponse(access_token=mock_token)


# ============================================================================
# API ENDPOINTS - WATCHTOWER (ALERTS)
# ============================================================================

@app.get("/api/v1/alerts", response_model=List[ComplianceAlertResponse])
async def get_alerts(skip: int = 0, limit: int = 10):
    """
    Fetch all compliance alerts detected by Watchtower.
    
    Query Parameters:
        skip: Number of alerts to skip (for pagination)
        limit: Maximum number of alerts to return
    
    Returns:
        List of ComplianceAlert objects
    """
    db = SessionLocal()
    try:
        alerts = db.query(ComplianceAlert).offset(skip).limit(limit).all()
        logger.info(f"âœ“ Fetched {len(alerts)} alerts")
        return alerts
    except Exception as e:
        logger.error(f"âœ— Failed to fetch alerts: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch alerts")
    finally:
        db.close()


@app.get("/api/v1/alerts/{alert_id}", response_model=ComplianceAlertResponse)
async def get_alert(alert_id: int):
    """
    Fetch a specific compliance alert by ID.
    
    Path Parameters:
        alert_id: ID of the alert
    
    Returns:
        ComplianceAlert object
    """
    db = SessionLocal()
    try:
        alert = db.query(ComplianceAlert).filter(ComplianceAlert.id == alert_id).first()
        if not alert:
            raise HTTPException(status_code=404, detail="Alert not found")
        return alert
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"âœ— Failed to fetch alert {alert_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch alert")
    finally:
        db.close()


# ============================================================================
# API ENDPOINTS - EXECUTOR (REPORT GENERATION)
# ============================================================================

@app.post("/api/v1/reports/generate")
async def generate_report(alert_id: int, background_tasks: BackgroundTasks):
    """
    Trigger the Executor to generate a compliance report from an alert.
    
    The report generation happens in the background via crew.ai agents.
    
    Query Parameters:
        alert_id: ID of the ComplianceAlert to analyze
    
    Returns:
        Confirmation message with report ID
    """
    db = SessionLocal()
    try:
        # Fetch the alert
        alert = db.query(ComplianceAlert).filter(ComplianceAlert.id == alert_id).first()
        if not alert:
            raise HTTPException(status_code=404, detail="Alert not found")
        
        # Create report record
        report = GeneratedReport(
            alert_id=alert_id,
            status="in_progress",
            title=f"Compliance Report for Alert #{alert_id}",
            content_markdown="",
        )
        db.add(report)
        db.commit()
        report_id = report.id
        
        # Add background task to generate report
        background_tasks.add_task(
            _execute_report_generation,
            report_id=report_id,
            alert_id=alert_id,
        )
        
        logger.info(f"âœ“ Report generation started for alert {alert_id} (Report ID: {report_id})")
        return {"report_id": report_id, "status": "in_progress"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"âœ— Failed to initiate report generation: {e}")
        raise HTTPException(status_code=500, detail="Failed to initiate report generation")
    finally:
        db.close()


def _execute_report_generation(report_id: int, alert_id: int):
    """
    Background task that executes the Executor crew to generate a report.
    
    Args:
        report_id: ID of the GeneratedReport to update
        alert_id: ID of the ComplianceAlert to analyze
    """
    db = SessionLocal()
    try:
        # Fetch alert and report
        alert = db.query(ComplianceAlert).filter(ComplianceAlert.id == alert_id).first()
        report = db.query(GeneratedReport).filter(GeneratedReport.id == report_id).first()
        
        if not alert or not report:
            logger.error(f"âœ— Alert or Report not found: alert_id={alert_id}, report_id={report_id}")
            return
        
        logger.info(f"ðŸ“‹ EXECUTOR: Starting report generation for Alert #{alert_id}")
        
        if GEMINI_API_KEY and llm:
            # Real crew.ai execution
            logger.info("âœ“ EXECUTOR: Using real Gemini API")
            
            try:
                # Mock company data (in real implementation, this would come from a real data source)
                company_data = {
                    "company_name": "Startup Inc.",
                    "data_locations": ["aws-uae-north-1", "gcp-dammam"],
                    "user_count": 45000,
                }
                
                # Define crew.ai tasks
                task_analyze = Task(
                    description=f"""Analyze this compliance alert:
                    {alert.summary}
                    
                    Provide a structured analysis including impact and required actions.""",
                    agent=get_compliance_analyst_agent(),
                    expected_output="Structured compliance analysis",
                )
                
                task_fetch_data = Task(
                    description="Fetch company data for compliance reporting",
                    agent=get_company_data_fetcher_agent(),
                    expected_output="JSON company metadata",
                )
                
                task_write_report = Task(
                    description=f"""Write a comprehensive compliance report in Markdown based on:
                    1. Alert: {alert.summary}
                    2. Company: {company_data['company_name']}
                    3. Impact level: {alert.impact_json.get('impact', 'Medium')}
                    
                    Include executive summary, findings, and recommendations.""",
                    agent=get_report_writer_agent(),
                    expected_output="Full Markdown report",
                )
                
                # Create and execute crew
                crew = Crew(
                    agents=[
                        get_compliance_analyst_agent(),
                        get_company_data_fetcher_agent(),
                        get_report_writer_agent(),
                    ],
                    tasks=[task_analyze, task_fetch_data, task_write_report],
                    verbose=True,
                )
                
                result = crew.kickoff()
                report_content = str(result)
                logger.info("âœ“ EXECUTOR: Report generation completed with real API")
            
            except Exception as e:
                logger.warning(f"âš  EXECUTOR: Real API failed: {e}. Falling back to mock.")
                company_data = {
                    "company_name": "Startup Inc.",
                    "data_locations": ["aws-uae-north-1", "gcp-dammam"],
                    "user_count": 45000,
                }
                report_content = generate_mock_executor_report(alert, company_data)
        else:
            # Mock report generation
            logger.info("EXECUTOR: No API key. Generating mock report.")
            company_data = {
                "company_name": "Startup Inc.",
                "data_locations": ["aws-uae-north-1", "gcp-dammam"],
                "user_count": 45000,
            }
            report_content = generate_mock_executor_report(alert, company_data)
        
        # Update report in database
        report.status = "completed"
        report.content_markdown = report_content
        db.commit()
        logger.info(f"âœ“ EXECUTOR: Report saved to DB (ID: {report_id})")
    
    except Exception as e:
        logger.error(f"âœ— EXECUTOR: Report generation failed: {e}")
        try:
            report = db.query(GeneratedReport).filter(GeneratedReport.id == report_id).first()
            if report:
                report.status = "failed"
                db.commit()
        except:
            pass
    finally:
        db.close()


@app.get("/api/v1/reports", response_model=List[GeneratedReportResponse])
async def get_reports(skip: int = 0, limit: int = 10):
    """
    Fetch all generated compliance reports.
    
    Query Parameters:
        skip: Number of reports to skip (for pagination)
        limit: Maximum number of reports to return
    
    Returns:
        List of GeneratedReport objects
    """
    db = SessionLocal()
    try:
        reports = db.query(GeneratedReport).offset(skip).limit(limit).all()
        logger.info(f"âœ“ Fetched {len(reports)} reports")
        return reports
    except Exception as e:
        logger.error(f"âœ— Failed to fetch reports: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch reports")
    finally:
        db.close()


@app.get("/api/v1/reports/{report_id}", response_model=GeneratedReportResponse)
async def get_report(report_id: int):
    """
    Fetch a specific generated report by ID.
    
    Path Parameters:
        report_id: ID of the report
    
    Returns:
        GeneratedReport object
    """
    db = SessionLocal()
    try:
        report = db.query(GeneratedReport).filter(GeneratedReport.id == report_id).first()
        if not report:
            raise HTTPException(status_code=404, detail="Report not found")
        return report
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"âœ— Failed to fetch report {report_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to fetch report")
    finally:
        db.close()


# ============================================================================
# API ENDPOINTS - RELIABLE CHAT (RAG)
# ============================================================================

@app.post("/api/v1/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """
    RAG-based compliance Q&A endpoint.
    
    Searches mock vector store for relevant context and returns an answer.
    
    Args:
        request: ChatRequest with query string
    
    Returns:
        ChatResponse with answer and source
    """
    query = request.query.lower()
    
    # Search mock vector store for relevant context
    context = None
    matched_key = None
    for key in mock_vector_store:
        if key in query:
            context = mock_vector_store[key]
            matched_key = key
            break
    
    # If no context found, provide a generic response
    if not context:
        context = (
            "No specific compliance context found for this query. "
            "Please refine your question or contact compliance team."
        )
        matched_key = "general"
    
    logger.info(f"ðŸ¤– CHAT: Query received: '{request.query}' (Matched: {matched_key})")
    
    if GEMINI_API_KEY and llm:
        # Real API call with RAG
        try:
            rag_prompt = f"""You are a compliance expert assistant. 
            
Context from compliance documentation:
{context}

User Question: {request.query}

Answer based ONLY on the context above. If the context doesn't answer the question, say so."""
            
            response = llm.invoke(rag_prompt)
            answer = response.content
            source = f"Compliance DB (Key: {matched_key})"
            logger.info("âœ“ CHAT: Real API response generated")
        
        except Exception as e:
            logger.warning(f"âš  CHAT: Real API failed: {e}. Falling back to mock.")
            answer = f"This is a mock answer. Based on your query, I found this context: {context}"
            source = f"Mock: {matched_key.upper()}"
    else:
        # Mock response (no API key)
        logger.info("CHAT: No API key. Generating mock response.")
        answer = f"This is a mock answer. Based on your query, I found this context: {context}"
        source = f"Mock: {matched_key.upper()}"
    
    return ChatResponse(answer=answer, source=source)


# ============================================================================
# HEALTH CHECK ENDPOINT
# ============================================================================

@app.get("/health")
async def health_check():
    """
    Simple health check endpoint.
    Returns API status and configuration info.
    """
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "api_key_configured": bool(GEMINI_API_KEY),
        "mode": "Production" if GEMINI_API_KEY else "Mock",
        "version": "1.0.0",
    }


# ============================================================================
# ROOT ENDPOINT
# ============================================================================

@app.get("/")
async def root():
    """Root endpoint with API documentation."""
    return {
        "message": "CompliOps API",
        "description": "Compliance Automation Platform with Agentic AI",
        "docs": "/docs",
        "health": "/health",
    }


# ============================================================================
# MAIN
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    
    logger.info("ðŸš€ Starting CompliOps Backend Server...")
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
    )
